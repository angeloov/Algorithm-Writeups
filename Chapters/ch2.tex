\chapterimage{chapter_head_1.pdf} % Chapter heading image
\chapter{Dynamic programming}

\subsection{A. Gellyfish and Flaming peony}
\begin{sloppypar}
\url{https://codeforces.com/problemset/problem/2115/A} 
\end{sloppypar}

It can be shown that ultimately all elements become 
$$ G = \gcd(a_1, a_2, \ldots, a_n). $$
\begin{obs}
If there is an element \( a_k = G \), then all the other elements will become \( G \).  
We just need to count the number of elements where \( a_i \neq G \ \forall i \).
\end{obs}

But if initially \( G \notin a \), then we have to calculate the number of operations to make an element in \( a \) equal to \( G \).  
We can do this using dynamic programming,
$$ f(x) = \text{\# of operations to make an element in } a \text{ equal to } x. $$

the transition equation is
$$ f(\gcd(x, a_i)) = f(x) + 1 $$

computed \( \forall x \in [\max(a) \dots 1], \quad \forall i \in \{1, 2, \ldots, n\} \)  
by updating when we find a smaller value at every iteration.

In addition, \( \gcd(a, b) \) takes \( \log(a) \) time so we need to preprocess the \texttt{gcd} function to avoid the complexity. To compute the 2 nested \texttt{for} loops will take
\[
\mathcal{O}(n \cdot \max(a) \cdot \log(\max(a)))
\]

We create a matrix for which
$$ \gcd[x][y] = \gcd[y][x] = \gcd[y][x \bmod y] $$

and this takes \( \mathcal{O}(\max(a) \cdot n) \), but we have the constraints:  
$$ 1 \leq a_i, n \leq 5000, $$
so the complexity is really  
\[
\mathcal{O}(\max(a)^2) = \mathcal{O}(n^2), \quad \text{which will be at most } (5 \cdot 10^3)^2 = 25 \cdot 10^6 \text{ operations, which is acceptable.}
\]

Therefore, we would have:
\[
\begin{array}{c|c}
\textbf{Preprocessing} & \textbf{Per Test Case} \\
\hline
\mathcal{O}(\max(a)^2) = \mathcal{O}(n^2) & \mathcal{O}(n \cdot \max(a)) = \mathcal{O}(n^2)
\end{array}
\]
\[
= \mathcal{O}(n^2) + \mathcal{O}(n^2) = \mathcal{O}(n^2)
\]

You can visualize the solution as: there is a chain of operations you do that interconnects the elements in a, and to get to g you choose one of the chains.
If you visualize it so, there are a lot of paths to take, and we eventually could arrive at the same number \( x_k \) via different paths; but in general for a specific point you are in the chain, you want the minimum cost out of all the possible paths.

And how can you take all the good possible paths? \\
By enumerating all possible \( x \)'s and all possible \( a_i \)'s.

\begin{obs}
    We know $\gcd(x, a_i) \leq x$ hence the choice of enumerating x from $\max(a)$ to $1$. Because we first fill $f(x)$ and then we can use those values to fill $f(gcd(x, a_i))$.
\end{obs}


\begin{minted}{C++}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
#define debug(x) cout << #x << " = " << x << '\n';
#define vdebug(a) cout << #a << " = "; for(auto x: a) cout << x << " "; cout << '\n';
typedef vector<ll> vi;
typedef pair<ll, ll> pi;

#define N 5005
ll g[N][N];

void test_case() {
  ll n; cin >> n;
  vi a(n), f(N, LLONG_MAX / 2LL);
  ll mx = 0, k = 0; // mx = max(a), k = gcd(a[0], ... , a[n-1])

  for (ll &x : a) {
    cin >> x;
    k = g[k][x];
  }
  
  for (ll &x : a) {
    // x /= k;
    mx = max(mx, x);
    f[x] = 0;
  } 
  
  for (ll x = mx; x >= 1; x--) {
    for (ll &y : a) {
      // remember that we want to minimize the number of operations
      if (f[g[x][y]] > f[x] + 1)
        f[g[x][y]] = f[x] + 1;
    }
  }
  
  ll ans = max(f[k] - 1, 0LL);
  for (ll &x : a) 
    if (x > k) ans++;

  cout << ans << endl;
}

int32_t main() {
  ios_base::sync_with_stdio(0); cin.tie(0);

  for (ll i=0; i<N; i++) g[i][0] = g[0][i] = g[i][i] = i;
  for (ll x=1; x<N; x++) {
    for (ll y=1; y<x; y++) {
      g[x][y] = g[y][x] = g[y][x % y];
    }
  }

  int t;
  cin >> t;
  while (t--) {
    test_case();    
  }
}
\end{minted}

\subsection{Book shop}
\begin{sloppypar}
\url{https://cses.fi/problemset/task/1158}
\end{sloppypar}

This problem is equivalent to the classical \textbf{knapsack problem}. This problem comes down to analysing 2 cases only:
\\
\begin{itemize}
    \item \textbf{Excluding the $i$-th item}, in which case the best solution is the same as the one obtained by considering only the items with indices from $1$ to $i - 1$;
    
    \item \textbf{Including the $i$-th item}, in which case the best solution is obtained by using $h_i$ units of capacity for the new item, and optimally using the remaining $j - h_i$ units of capacity for the previous items.
\end{itemize}


\begin{center}
\begin{tikzpicture}[every node/.style={font=\normalsize}]
    % Main DP formula
    \node (dp) at (0,0) {$
        \text{dp}[i][j] = \max\left(
            \begin{array}{l}
                \text{dp}[i - 1][j], \\
                \text{dp}[i - 1][j - h_i] + s_i
            \end{array}
        \right)
    $};
\end{tikzpicture}
\end{center}

where we define dp[$i$][$j$] as the maximum number of pages we can buy with $j$ dollars and including all the books from $1$ to $i$.


\subsection{Counting Towers}
\begin{sloppypar}
\url{https://cses.fi/problemset/task/2413}
\end{sloppypar}

We distinguish between type 1 towers, and type 2. Type 1 towers have the the top two cells connected, while type 2 towers have the top two cells that are part of different blocks.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.5\linewidth]{Pictures/2-1.png}
    \caption{2 types of towers}
    \label{fig:21}
\end{figure}

We let $a_n$ = no. of towers of type 1 of height $n$, $b_n$ = no. of towers of type 2 of height $n$.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.75\linewidth]{Pictures/2-2.png}
    \caption{We can view the line below the $i$-th row as open or closed.}
    \label{fig:22}
\end{figure}

\subsubsection{Type 1 towers}
If we have the top 2 cells connected ($i$-th row) the dotted line (Figure \ref{fig:22}) could be empty or filled and then below it we either put a tower $(i - 1) \times 2$ of type 1. Otherwise the dotted line is filled and then we put a tower $(i - 1) \times 2$ of type 2.

\begin{equation}
    a_n = 2a_{n-1} + b_{n-1}
\end{equation}

\subsubsection{Type 2 towers}
For a type 2 tower we have a line that splits vertically the top 2 cells (see figure \ref{fig:21}) and the dotted line show in figure \ref{fig:22} can be either filled or open, leading to \textbf{4 possible states}. Below this line we could fill with type 2 towers. If we want to fill the remaining spaces with a type 1 tower we have to account for the fact that its top two cells have to be part of the same block, so the dotted line is \textit{filled}. This leads to only \textbf{1 possible state}.

\begin{equation}
    b_n = 4b_{n-1} + a_{n-1}
\end{equation}

The number of towers is $a_n + b_n$. We simply compute every value of $a_i, b_i$ leading to a complexity of $O(n)$.

\begin{minted}{c++}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
#define debug(x) cout << #x << " = " << x << '\n';
#define vdebug(a) cout << #a << " = "; for(auto x: a) cout << x << " "; cout << '\n';
typedef vector<ll> vi;
typedef pair<ll, ll> pi;

const ll mod = 1e9 + 7;

void test_case() {
  ll n; cin >> n; 
  
  ll a = 1, b = 1;
  if (n == 0) cout << "0\n";
  else if (n == 1) cout << "2\n";
  else {
    for (ll i = 2; i <= n; i++) {
      ll newa = (2*a + b) % mod;
      ll newb = (4*b + a) % mod;
  
      a = newa, b = newb;
    }
  
    cout << (a + b) % mod << endl;
  }
}
\end{minted}

\section{Constructing permutations and combinations}

\subsection{Coin combinations I \&\& II: swapping two loops can change the result!}
\begin{sloppypar}
\url{https://cses.fi/problemset/task/1635}, \url{https://cses.fi/problemset/task/1636} 
\end{sloppypar}

\subsubsection{Coin combinations I}
The first problem asks us to calculate all the distinct \textit{permutations} of a set of coins to produce a certain sum of money $x$. 
\begin{equation}
    \text{dp}[i] = \text{\# of permutations of coins that sum up to amount } i.
\end{equation}

\begin{minted}{c++}
void test_case() {
  ll n, x; cin >> n >> x;
  vector<ll> c(n);
  vector<ll> dp(x+1, 0);
  for (auto &x : c) cin >> x;

  dp[0] = 1;

  for (ll i = 1; i <= x; i++) {
    for (ll coin : c) {
      if (i - coin >= 0)
        dp[i] += (dp[i - coin] % mod);
    }
  }
  
  cout << (dp[x] % mod) << endl;
}

\end{minted}

The approach we take is iterating through the amounts $i$ ($1 \leq i \leq x$) and then trying all the possible coins to make that amount. If we want to make amount $i$, there are $\text{dp}[i - c]$ ways of doing that, where $c$ is a coin in the set that we use to complete the permutation. 
That is we are constructing all the permutations of this kind,

\begin{equation}
    (c, (\text{all the permutations that sum up to } i - c \text{ go here}))
\end{equation}


\subsubsection{Coin combinations II}

Here what's asked is to count the number of \textit{combinations} to make an amount $x$ with a given input set of coins. 

The approach we take is to select a coin $c$, and from here compute
\begin{equation}
    \text{dp}[i] = \text{\# of combinations using the given coins to reach amount } i, \forall i\ (1 \leq i \leq x). 
\end{equation}


\begin{idea}
    Here adding $3 + 1$ is the same as adding $1 + 3$, this means that we need to consider the coins in order. So we only go through the set of coins once, thus it's impossible to create two combinations with the same set of coins ordered differently. This is different from the previous problem where we considered every coin at all times.
\end{idea}

We get a time complexity of $\mathcal{O}(n \cdot x)$.

\begin{minted}{c++}
void test_case() {
  ll n, x; cin >> n >> x;
  vector<ll> c(n);
  vector<ll> dp(x+1, 0);
  for (auto &x : c) cin >> x;

  dp[0] = 1;

  for (ll coin : c) {
    for (ll i = 1; i <= x; i++) {
      if (i - coin >= 0)
        dp[i] += (dp[i - coin] % mod);
    }
  }
  
  cout << (dp[x] % mod) << endl;
}
\end{minted}

At every iteration of the outer loop we add a coin to the ones that we are using in order to construct the combinations. That is, at the first iteration we are calculating how to make all the possible amounts $1 \leq i \leq x$ only using the first coin. At the second iteration only using the first two coins, and so forth.

This means that we could have done the same job using a matrix instead of iterating on the same array multiple times by defining
\begin{equation}
    \text{dp}[j][i] = \text{\# of combinations to produce a sum of money $i$ using the first $j$ coins}.
\end{equation}

\subsection{Dice Sum}
\url{https://atcoder.jp/contests/abc248/tasks/abc248_c} \\ 

We want to construct all the permutations of this kind,
\begin{equation}
    (A_1, \dots, A_n)
\end{equation}

where $A_i \in [1 \dots M]$ and $\sum_{1 \leq i\leq N}{A_i} \leq K$.

What we do is again, as we did in Coin Combinations I, first try to place $A_1$ in the beginning of the permutation and then construct the sum of the amount of permutations that have length $n - 1$. 

\begin{minted}{c++}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
#define debug(x) cout << #x << " = " << x << '\n';
#define vdebug(a) cout << #a << " = "; for(auto x: a) cout << x << " "; cout << '\n';
typedef vector<ll> vi;
typedef pair<ll, ll> pi;

const ll mod = 998244353LL;

void test_case() {
  ll N, M, K; cin >> N >> M >> K;

  // dp[i][k] = # of sequences of length i and sum = k.
  vector<vi> dp(N+1, vi(K+1));

  for (ll k = 1; k <= K; k++) {
    if (k <= M)
      dp[1][k] = 1;
  }

  for (ll i = 1; i <= min(N, K); i++)
    dp[i][i] = 1;
  
  for (ll i = 2; i <= N; i++) { // len
    for (ll k = i+1; k <= K; k++) { // sum

      for (ll p = 1; p <= M; p++) {
        if (k - p >= 1)
          dp[i][k] += (dp[i-1][k - p] % mod);
      }

    }
  }

  // sequences of len N where sum <= K
  cout << accumulate(dp.back().begin(), dp.back().end(), 0LL) % mod << endl;
}

int32_t main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  test_case();
}
\end{minted}

\section{Speeding up with Segment Trees}

\subsection{A - Card game}
\url{https://codeforces.com/gym/104945/problem/A}

Consider a deck of \( N \) cards with suits \( \{S, W, E, R, C\} \). 
Our goal is to reorder the deck so that the cards are sorted within each suit 
(e.g., \( S_1, S_2, \ldots, S_N \)), and the suits appear in any arbitrary order, 
except that the suit \( C \) must always be placed last.
We can rearrange the cards by choosing one and putting it in the middle of two cards, at the beginning, or at the end of the deck. The problem asks: what's the minimum number of moves we can make?

\begin{obs}
    Consider you have a deck of cards in your hand. You'll have cards already ordered, and others which are not. Those ones already ordered stay there, while only the not ordered cards will be moved.
\end{obs}

The number of cards already in order is the LIS (Longest Increasing Subsequence). Therefore, the number of cards that have to move is $N - \text{LIS}(a)$ where a is the array of cards.
We can compute this with a $O(n^2)$ complexity.

\begin{minted}{c++}
void test_case() {
  ll n; cin >> n;
  vector<pair<char, ll>> d(n);

  for (auto &x : d) {
    char c; cin >> c;
    ll b; cin >> b;

    x.first = c, x.second = b;
  }

  string str = "SWER";

  auto offset = [&](char c) {
    if (c == 'C') return 4 * n;
    return (ll)str.find(c) * n;
  };

  auto access = [&](ll i) {
    return offset(d[i].first) + d[i].second;
  };

  ll mxlis = 0;
  for (ll k = 0; k < 24; k++) { // Traverse all permutations of "SWER"
    vi dp(n, 1);
    
    // LIS (Longest Increasing Subsequence) calculation
    // dp[i] = longest increasing subsequence if we consider
    //         a[i] as the last element of the sequence.
    for (ll i = 1; i < n; i++) {
      for (ll j = 0; j < i; j++) {
        // This is a conversion made to preserve the total ordering defined by the problem
        ll aj = offset(d[j].first) + d[j].second;
        ll ai = offset(d[i].first) + d[i].second;
      
        if (aj < ai)
          dp[i] = max(dp[i], dp[j] + 1LL);
      }
    }

    ll lis = *max_element(dp.begin(), dp.end());
    next_permutation(str.begin(), str.end());
    mxlis = max(mxlis, lis);
  }

  cout << n - mxlis << "\n";
}
\end{minted}

But this solution, is too slow. Now, ask yourself: when constructing a LIS what are the values that are gonna be before a given element of the sequence $a_i$? The answer is: all the values in $[0 \dots a_i -1 ]$.

What we can do is use a segment tree to speed things up where its array of leaves maps $\text{leaves}[a[i]]$ to \textbf{the maximum LIS obtainable by having $a[i]$ as the last element}. Therefore,
\begin{equation}
    \text{dp}[i] = \text{tree.query}(0 , a[i] -1) + 1
\end{equation}
and every time we compute $\text{dp}[i]$ we also update the value of the maximum LIS obtainable by having $\text{a}[i]$ as the last element of the sequence, so we have to update the array of leaves.

\begin{minted}{c++}
#include <bits/stdc++.h>
using namespace std;
using ll=long long;
#define debug(x) cout << #x << " = " << x << '\n';
#define vdebug(a) cout << #a << " = "; for(auto x: a) cout << x << " "; cout << '\n';
typedef vector<ll> vi;
typedef pair<ll, ll> pi;

class SegmentTree {
private:
  vector<ll> tree;
  ll n;

public:
  SegmentTree(ll size) {
    n = size;
    tree.resize(2 * n, 0);
  }

  // Query maximum in range [left, right] iteratively
  ll query(ll left, ll right) {
    left += n;  // Shift to leaf nodes
    right += n;
    ll result = 0;
        
    while (left <= right) {
      if (left % 2 == 1) {  // left is a right child
        result = max(result, tree[left]);
        left++;
      }
      if (right % 2 == 0) {  // right is a left child
        result = max(result, tree[right]);
        right--;
      }
      left /= 2;   // Move to parent
      right /= 2;
    }
        
    return result;
  }

  // Update value at position idx iteratively
  void update(ll idx, ll val) {
    idx += n;  // Start at leaf
    tree[idx] = max(tree[idx], val);  // Update with maximum value
        
    // Update parents
    while (idx > 1) {
      idx /= 2;
      tree[idx] = max(tree[idx*2], tree[idx*2+1]);
    }
  }
};

void test_case() {
  ll n; cin >> n;
  vector<pair<char, ll>> d(n);

  for (auto &x : d) {
    char c; cin >> c;
    ll b; cin >> b;

    x.first = c, x.second = b;
  }

  string str = "SWER";

  ll mxlis = 0;
  for (ll k = 0; k < 24; k++) { // Traverse all permutations of "SWER"
    vi a(n);
    ll mxelem = 0LL;
    for (ll i = 0 ; i < n; i++) {
      // Calculation of a[i] offsetted based on letter {S, W, E, R, C}
      ll offset;
      if (d[i].first == 'C') offset = 4 * n;
      else offset = (ll)str.find(d[i].first) * n;

      a[i] = offset + d[i].second;
      mxelem = max(mxelem, a[i]);
    }

    vi dp(n, 1);
    SegmentTree tree(mxelem + 1);

    // LIS (Longest Increasing Subsequence) calculation.
    // dp[i] = longest increasing subsequence if we consider
    //         a[i] as the last element of the sequence.
    for (ll i = 0; i < n; i++) {
      dp[i] = tree.query(0, a[i] - 1) + 1;

      ll last_value = tree.query(a[i], a[i]);
      tree.update(a[i], max(last_value, dp[i]));
    }
    
    ll lis = *max_element(dp.begin(), dp.end());
    next_permutation(str.begin(), str.end());
    mxlis = max(mxlis, lis);
  }

  cout << n - mxlis << "\n";
}

int32_t main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  test_case();
}
    
\end{minted}